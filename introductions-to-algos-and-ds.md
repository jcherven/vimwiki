# intro-to-algos-and-ds

Whenever we want to solve a problem, we go through a series of steps to do so. This series of steps is called an algorithm. There might be more than one algorithm for solving a particular problem, and we can compare and evaluate them in several different ways. 

For example, let’s say we want to find out what the answer to the equation “2 x 4” is. We could draw two rows of four dots, and count them. We could add 2 to 0 four times. We could draw two parallel lines, intersect those with 4 other parallel lines, and count the points of intersection. Or maybe we just work out the answer once, memorize it forever, and recall it when needed. 

In all of these solutions, we realize that the steps we are going through to solve 2x4 can be used to solve any multiplication problem. This is important – an algorithm is just a series of steps taken to solve a particular type of problem. The actual inputs given may be different. 

When we write code, we write a series of instructions that are – for the most part – going to be executed in a predictable order. Any program can be seen as a single giant algorithm, but that’s too broad brush. Instead, it’s better to recognize that a program is made up of multiple smaller algorithms. Each thing a program does, it uses a repeatable series of steps to do. 

When designing algorithms for software and code, there are two resources we use to rank and evaluate algorithms: time and memory. Obviously an algorithm that runs faster and requires less memory is going to be a superior one, but it’s rare that an algorithm for a difficult problem will be able to have both. 

So given these two ideas: all programs use algorithms to accomplish their goals, and algorithms can be effectively ranked by their time and memory requirements,then it’s clear to see that improving the qualities of the algorithms that an application uses will improve the application as a whole. This seems simple and obvious, but the implications are profound. Google indexes over 130 trillion web pages, and receives over 40,000 search requests every second. If you could speed up the algorithm Google uses to find search results by just 1%, Google could handle 34 million additional requests every day. Those 130 trillion indexing records take over 450,000 terabytes of space. If you could improve the algorithm used to compress those records by 1%, you could reduce the space needed by 4,500 terabytes. A one-terabyte hard drive is about $60, so you just saved Google $270,000 in hardware costs alone, not to mention reduced electricity costs and reduced AC costs to compensate for the heat generated by 4,500 hard drives and the hardware to use them. 

The programs you write for fun might not benefit from improvements to algorithmic complexity, but these concepts matter a lot to every software company in the world. If their software is too slow, their users are less productive. If a webpage takes too long to load, nobody will look at it. Strong algorithms can be the difference between success and failure for a startup. 

Most algorithms, when you get right down to it, are just about processing data in some way. That processing might mean sorting data, searching it for a value, or transforming it in some way. You can think of an algorithm as a box, into which inputs go, and out of which you receive an output. But the way that input data is structured and organized can have a big impact on the performance of an algorithm – or how that algorithm can be designed in the first place!

The different ways of organizing data in programs are called data structures. Different data structures have different properties that make them better or worse at certain tasks. For example, it’s a quick task to add an item to a linked list, but finding a particular item to retrieve can be more time consuming. Arrays have super quick lookup times, but their size is fixed entirely. 

In this series, we’re going to start our discussion of algorithms by discussing the different properties and uses of the data structures you can use in your algorithms. You’ll often find that designing an efficient algorithm requires using the right data structure, so it’s important to know your options before you start. 
